# region Calculate additional hashing metrics (if used). --------------------------------------------------------------

    if "hashing" in qc:
        # We calculate the following metrics:
        # - Total no. of hash reads per cell.
        # - Total no. of unique hash/UMI combinations per cell.
        
        # Open file-handlers to store hashing metrics.
        path_hashing = os.path.join(path_out, qc["sequencing_name"] + "_hashing_metrics.txt")
        fh_hashing = open(path_hashing, "w")

        # Write header.
        fh_hashing.write("sequencing_name\thash_barcode\tcell_barcode\tn_hash\tn_hash_umi\n")
        sequencing_name = qc["sequencing_name"]

        for hash_barcode in qc["hashing"]:
            for cell_barcode in qc["hashing"][hash_barcode]["counts"]:
                qc["hashing"][hash_barcode]["counts"][cell_barcode]["n_umi"] = len(qc["hashing"][hash_barcode]["counts"][cell_barcode]["umi"])
                del qc["hashing"][hash_barcode]["counts"][cell_barcode]["umi"]

                # Write metrics to file.
                fh_hashing.write(f"{sequencing_name}\t{hash_barcode}\t{cell_barcode}\t{qc['hashing'][hash_barcode]['counts'][cell_barcode]['count']}\t{qc['hashing'][hash_barcode]['counts'][cell_barcode]['n_umi']}\n")

    # Close file-handlers.
    fh_hashing.close()

    # endregion


def main(arguments):
    description = """
    Performs demultiplexing on R1/R2.fastq(.gz) files generated by sci-RNA-seq v3 protocol, based on:
        - p7, p5, RT and ligation barcodes.
        - Collects hashing metrics (if applicable).
            - Reads used for hashing are removed.
    
    The R1 sequence is modified to a fixed length sequence (48nt) which includes all (corrected) barcodes: p5(10nt), p7(10nt), ligation(10nt), RT(10nt) and UMI (8nt) for downstream processing.
    The read names for R2 are modified to include the barcodes and UMI.
    
    It requires that the p5 and p7 barcodes are present in the read headers of the .fastq files (bcl2fastq):
    @<read name> 1:N:0:ACGGNNGGCC+NTCATGGNGC
                      |----p7---|+|----p5----|: p5 is reverse-complemented.

    The R1 sequence should adhere to the following scheme:
    First 9 or 10nt:  Ligation barcode
    Next 8nt:    UMI
    Next 6nt:    Primer
    Last 10nt:   RT Barcode (sample-specific)

    Anatomy of R1:
    |ACTTGATTGT| |GAGAGCTC| |CGTGAA| |AGGTTAGCAT|
    |-LIGATION-| |---UMI--| |Primer| |----RT----|
    """

    # Setup argument parser.
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.RawTextHelpFormatter, add_help=False)
    parser.add_argument("--r1", required=True, type=str, help="(.fq) Input fastq (R1).")
    parser.add_argument("--r2", required=True, type=str, help="(.fq) Input fastq (R2).")
    parser.add_argument("--sequencing_name", required=True, type=str, help="(str) Sequencing sample name.")
    parser.add_argument("--samples", required=True, type=str, help="(str) Path to sample-sheet.")
    parser.add_argument("--barcodes", required=True, type=str, help="(str) Path to barcodes file.")
    parser.add_argument("--hashing", required=False, type=str, help="(str) Path to hashing sheet.")
    parser.add_argument("--out", required=True, type=str, help="(str) Path to output directory.")

    parser.add_argument("-h", "--help", action="help", default=argparse.SUPPRESS, help="Display help and exit.")
    parser.add_argument("-v", "--version", action="version", version=__version__, help="Display version and exit.")

    # Parse arguments.
    args = parser.parse_args()

    # Initialize logging.
    log = init_logger()

    # Open sample-sheet.
    samples = pd.read_csv(args.samples, sep="\t", dtype=str)
    samples = samples.query("sequencing_name == @args.sequencing_name")

    # Open barcode-sheet.
    barcodes = pd.read_csv(args.barcodes, sep="\t", dtype=str)

    # Import hashing sheet (if any).
    hashing = {}
    if args.hashing:
        x = pd.read_csv(args.hashing, sep="\t", header=0)
        hashing = {**hashing, **dict(zip(x["barcode"], x["hash_name"]))}

    # Generate output directory if not exists.
    if not os.path.exists(args.out):
        os.makedirs(args.out)

    # Run the program.
    sciseq_sample_demultiplexing(log=log, sequencing_name=args.sequencing_name, samples=samples, barcodes=barcodes, hashing=hashing, path_r1=args.r1, path_r2=args.r2, path_out=args.out)


if __name__ == "__main__":
    main(sys.argv[1:])
    sys.exit()